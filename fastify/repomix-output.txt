src/
  helpers/
    auth.ts
    get-tickets.ts
    model.ts
  models/
    db.ts
    resp.ts
    signup.ts
    ticket-resp.ts
    ticket.ts
    user.ts
  index.ts
package.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/helpers/auth.ts
================
import * as bcrypt from "bcrypt";
import {Db, ObjectId} from "mongodb";
import {Model} from "./model";
import {DbSession, DbUser} from "../models/db";
import {PubUser} from "../models/user";

const MAX_SESSION_HOURS = 5 * 24;

export async function u_exits(db: Db, username: string): Promise<boolean> {
  return (await db.collection('users').countDocuments({username}, {limit: 1})) > 0;
}

export async function authorized_user(db: Db, username: string, password: string) {
  const user = await db.collection<DbUser>('users').findOne({username});
  if (!user) return null;

  const isValid = await bcrypt.compare(password, user.password);
  return isValid ? Model.toUser(user) : null;
}

/*
Returns user_id
 */
export async function u_create(db: Db, username: string, password: string): Promise<PubUser> {
  const salt = await bcrypt.genSalt(10);
  const hashedPassword = await bcrypt.hash(password, salt);
  const now = new Date();

  const result = await db.collection<DbUser>('users').insertOne({
    _id: new ObjectId(),
    username,
    password: hashedPassword,
    createdAt: now,
    updatedAt: now
  });

  return Model.toUser({
    _id: result.insertedId,
    username,
    password: hashedPassword,
    createdAt: now,
    updatedAt: now
  });
}

export async function create_session(db: Db, user_id: string) {
  const userObjectId = Model.toObjectId(user_id);
  if (!userObjectId) return null;

  const now = new Date();
  const expiredAt = new Date(now.getTime() + (MAX_SESSION_HOURS * 60 * 60 * 1000));

  // Check for existing valid session
  const existingSession = await db.collection<DbSession>('sessions').findOne({
    user_id: userObjectId,
    expiredAt: {$gt: now}
  });

  if (existingSession) {
    return Model.toSession(existingSession);
  }

  // Create new session
  const session = await db.collection<DbSession>('sessions').insertOne({
    _id: new ObjectId(),
    user_id: userObjectId,
    expiredAt
  });

  return Model.toSession({
    _id: session.insertedId,
    user_id: userObjectId,
    expiredAt
  });
}

export async function get_user(db: Db, session_id: string) {
  const sessionObjectId = Model.toObjectId(session_id);
  if (!sessionObjectId) return null;

  const now = new Date();
  const session = await db.collection<DbSession>('sessions').findOne({
    _id: sessionObjectId,
    expiredAt: {$gt: now}
  });

  if (!session) return null;

  const user = await db.collection<DbUser>('users').findOne({
    _id: session.user_id
  });

  return user ? Model.toUser(user) : null;
}

================
File: src/helpers/get-tickets.ts
================
import {PaginatedTicket} from "../models/ticket-resp";

export const getTickets = (): PaginatedTicket => {
  return {
    items: [],
    count: 0,
    hasMore: false
  }
}

================
File: src/helpers/model.ts
================
import {ObjectId} from '@fastify/mongodb'
import {PubUser, User} from "../models/user";
import {DbSession, DbUser} from "../models/db";
import {Session} from "../models/resp";

export class Model {
  static toObjectId(id: string): ObjectId | null {
    try {
      return new ObjectId(id);
    } catch {
      return null;
    }
  }

  static toUser(dbUser: DbUser): PubUser {
    return {
      _id: dbUser._id.toString(),
      username: dbUser.username,
      createdAt: dbUser.createdAt.toISOString(),
      updatedAt: dbUser.updatedAt.toISOString()
    };
  }

  static toSession(dbSession: DbSession): Session {
    return {
      _id: dbSession._id.toString(),
      user_id: dbSession.user_id.toString(),
      expiredAt: dbSession.expiredAt.toISOString()
    };
  }
}

================
File: src/models/db.ts
================
import {ObjectId} from "@fastify/mongodb";

export interface DbUser {
  _id: ObjectId;
  username: string;
  password: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface DbSession {
  _id: ObjectId;
  user_id: ObjectId;
  expiredAt: Date;
}

================
File: src/models/resp.ts
================
import {Static, Type} from '@sinclair/typebox'

export const MessageSchema = Type.Object({
  message: Type.String(),
  type_: Type.String(),
})

export const SessionSchema = Type.Object({
  user_id: Type.String(),
  expiredAt: Type.String(),
  _id: Type.String()
})

export type Message = Static<typeof MessageSchema>
export type Session = Static<typeof SessionSchema>

================
File: src/models/signup.ts
================
import {Static, Type} from '@sinclair/typebox'

export const SignUpSchema = Type.Object({
  username: Type.String(),
  password: Type.String(),
})


export const SessionHeadSchema = Type.Object({
  session_id: Type.String()
})
export type SignUpParams = Static<typeof SignUpSchema>
export type SessionHeadParams = Static<typeof SessionHeadSchema>

================
File: src/models/ticket-resp.ts
================
import {Type, Static} from '@sinclair/typebox'
import {TicketSchema} from './ticket'

export const TicketQuerystringSchema = Type.Object({
  search: Type.String(),
  order: Type.Integer()
})

export const PaginatedTicketSchema = Type.Object({
  items: Type.Array(TicketSchema),
  count: Type.Integer(),
  hasMore: Type.Boolean()
})

// Type exports
export type TicketQuerystring = Static<typeof TicketQuerystringSchema>
export type PaginatedTicket = Static<typeof PaginatedTicketSchema>

================
File: src/models/ticket.ts
================
import {Static, Type} from '@sinclair/typebox'

export const TicketSchema = Type.Object({
  id: Type.String(),
  name: Type.String(),
  createdAt: Type.String(),
  updatedAt: Type.String(),
  expiredAt: Type.String(),
  price: Type.Integer()
})

export type Ticket = Static<typeof TicketSchema>

================
File: src/models/user.ts
================
import {Static, Type} from '@sinclair/typebox'

export const UserSchema = Type.Object({
  username: Type.String(),
  password: Type.String(),
  createdAt: Type.String(),
  updatedAt: Type.String(),
  _id: Type.String(),
})

export const UserPubSchema = Type.Object({
  username: Type.String(),
  createdAt: Type.String(),
  updatedAt: Type.String(),
  _id: Type.String(),
})

export type User = Static<typeof UserSchema>
export type PubUser = Static<typeof UserPubSchema>

================
File: src/index.ts
================
import fastify from 'fastify'
import {
  TicketQuerystring,
  TicketQuerystringSchema,
  PaginatedTicket, PaginatedTicketSchema
} from "./models/ticket-resp";
import {getTickets} from "./helpers/get-tickets";
import {SessionHeadParams, SessionHeadSchema, SignUpParams, SignUpSchema} from "./models/signup";
import {Message, MessageSchema, Session, SessionSchema} from "./models/resp";
import type {Db, MongoClient} from 'mongodb'
import {u_create, u_exits, create_session, get_user, authorized_user} from "./helpers/auth";
import {PubUser, User, UserPubSchema, UserSchema} from "./models/user";

const server = fastify();

declare module 'fastify' {
  interface FastifyInstance {
    mongo: {
      client: MongoClient;
      db: Db;
    }
  }
}

server.register(require('@fastify/mongodb'), {
  // force to close the mongodb connection when app stopped
  // the default value is false
  forceClose: true,

  url: 'mongodb://localhost:27017/fun-ticket'
})


server.post<{
  Body: SignUpParams,
  Reply: {
    201: Session,
    400: Message
  }
}>(
  '/signup',
  {
    schema: {
      body: SignUpSchema,
      response: {
        201: SessionSchema,
        400: MessageSchema
      }
    },
  },
  async function (request, reply) {
    const {username, password} = request.body;
    let user_id: string;
    if (await u_exits(this.mongo.db, username)) {
      const user = await authorized_user(this.mongo.db, username, password);
      if (!user) {
        reply.code(400).send({
          message: "Do not match!",
          type_: "fail"
        });
        return;
      }
      user_id = user._id.toString();
    } else {
      user_id = (await u_create(this.mongo.db, username, password))._id;
    }
    const session = await create_session(this.mongo.db, user_id);
    reply.code(201).send(session);
  }
)

server.get<{
  Querystring: TicketQuerystring,
  Reply: PaginatedTicket
}>(
  '/list',
  {
    schema: {
      querystring: TicketQuerystringSchema,
      response: {
        200: PaginatedTicketSchema
      }
    }
  },
  function (request, reply) {
    const {search, order} = request.query;
    const paginatedTickets = getTickets();
    reply.code(200).send(paginatedTickets);
  })


server.get<{
  Headers: SessionHeadParams,
  Reply: {
    200: PubUser,
    404: Message
  }
}>(
  '/get-user',
  {
    schema: {
      response: {
        200: UserPubSchema,
        400: MessageSchema
      },
      headers: SessionHeadSchema
    }
  },
  async function (request, reply) {
    const {session_id} = request.headers;
    const user = await get_user(this.mongo.db, session_id);
    if (user) {
      reply.code(200).send(user);
    } else {
      reply.code(404).send({
        message: 'User not found',
        type_: 'fail'
      })
    }
  })


server.listen({port: 3000}, err => {
  if (err) throw err
})

================
File: package.json
================
{
  "name": "fastify-basics",
  "version": "1.0.0",
  "description": "",
  "main": "build/index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "../node_modules/.bin/tsc -p tsconfig.json",
    "start": "node build/index.js",
    "dev": "ts-node -T src/index.ts"
  },
  "private": true,
  "dependencies": {
    "@fastify/mongodb": "^9.0.2",
    "@sinclair/typebox": "^0.34.15",
    "bcrypt": "^5.1.1",
    "fastify": "^5.2.1"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/node": "^22.12.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.3"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "outDir": "./build",
    /* Specify the output folder for all emitted files */
    "rootDir": "./src",
    /* Specify the root folder within your source files */
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  },
  "include": [
    "fastify/src/**/*"
  ],
  /* Include only files in src directory */
  "exclude": [
    "../node_modules"
  ]
  /* Exclude node_modules directory */
}
